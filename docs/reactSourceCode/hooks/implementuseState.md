---
title: Hooks -- Implement useState
date: 2022-04-29
---

## Foreword

FOr better understanding for the `Hooks`, we are going to implement the `useState` hook within 100 lines code by following the workflow of `React`.

## Workflow

For `useState Hook`, think about the example of the following code:

```js
function App() {
  const [num, updateNum] = useState(0);

  return <p onClick={() => updateNum((num) => num + 1)}>{num}</p>;
}
```

We can devide the code into two parts:

1. `Update` happens and it trigger component `render`.
2. The return `num` is the updated result from `useState` when the component `render`.

In the step 1, `update` could be `mount` or `update`.

- `ReactDOM.render` trigger `mount`'s `update`, the context is the `initialValue` of `useState`, which is `0`.
- Clicking `p` tag trigger `updateNum` `update` again, the context is `num => num + 1`.

## What is update

Form the above example, we can see that `update` could happen and it trigger component `render`.

In our example, `Update` is the following data structure:

```js
const update = {
  // update function
  action,
  // chain table includes hook and other updates
  next: null,
};
```

As for `App`, the action triggered by clicking tag `p` is `num => num + 1`.

If we change the `onClick` of `App`

```js
// Before
return <p onClick={() => updateNum((num) => num + 1)}>{num}</p>;

// After
return (
  <p
    onClick={() => {
      updateNum((num) => num + 1);
      updateNum((num) => num + 1);
      updateNum((num) => num + 1);
    }}
  >
    {num}
  </p>
);
```

As the result, clicking `p` tag will triggers `Update` three times.

## Data Structure of Update

How could these `update`s be together or put in a group?

The answer is, they will form a circular circle linked list.

Calling `updateNum` is actually calling `dispatchAction.bind(null, hook.queue`), let's take a look at this function first

```js
function dispatchAction(queue, action) {
  // create update
  const update = {
    action,
    next: null,
  };

  // circular circle linked list
  if (queue.pending === null) {
    update.next = update;
  } else {
    update.next = queue.pending.next;
    queue.pending.next = update;
  }
  queue.pending = update;

  // mock sechedule update of React
  schedule();
}
```

When the first `update` happened(we name it `u0`), `queue.pending === null`.

`update.next = update;`, which is `u0.next = u0`. It will link the begining and the end of itself to be a circular circle linked list.

Then, `queue.pending = update`, `queue.pending = u0`.

```js
queue.pending = u0 ---> u0
                ^       |
                |       |
                ---------
```

When the second `update` happened(we name it `u1`), `update.next = queue.pending.next;`, and `queue.pending.next === u0`, `u1.next = u0`.

`queue.pending.next = update`, `u0.next = u1`.

Then, `queue.pending = update`, `queue.pending = u1`.

```js
queue.pending = u1 ---> u0
                ^       |
                |       |
                ---------
```

You can simulate the case of inserting multiple `Update` by following this example and you will see that` queue.pending` always points to the last inserted `Update`.

The good side of this is that when we want to iterate through the `Update`, `queue.pending.next` points to the first inserted `Update`.

## How to Save the State

Now we know that the `Update` object generated by `Update` saved in `queue`.

Different `ClassComponent` instance could store data, where does `queue` store as for `FunctionComponent`?

I will tell you it stores in the `FunctionComponent`'s corresponding `fiber`.

We can use the following `fiber` structure

```js
// App with corresponding fiber object
const fiber = {
  // save the corresponding Hooks linked list
  memoizedState: null,
  // points to the App function
  stateNode: App,
};
```

## Data Structure of Hook

Next, we are going to focus on the `Hook`'s data structure stored in the `fiber.memoizedState`.

`Hook` is similar to `Update`, connect by the linked list, but it is a circular non-circle linked list.

```js
hook = {
  // queue with saved update
  queue: {
    pending: null,
  },
  // corresponding state of the saved hook
  memoizedState: initialState,
  // generate a circular linked list with next Hook
  next: null,
};
```

::: warning
Identify the `Update` and `hook`

each `useState` has a corresponding `Hook`

When `const [nums, updateNum] = useState(0);`, the `update` generated by `updateNum`(which is the `dispatchAction`) saved in the `useState`'s corresponding `hook.queue`.
:::

## Mock the Workflow of Schdule Update in React

We know that we use `schedule` method to mock the workflow of React.

```js
function dispatchAction(queue, action) {
  // ...create update

  // ...circular circle linked list

  // mock React start scheduling update
  schedule();
}
```

Now, we are trying to implemente it.

Let's use `isMount` to indicate whether is `mount` or `update`.

```js
// when first time render, it is mount
isMount = true;

function schedule() {
  // reset workInProgressHoook as the first Hook saved by the fiber before update
  workInProgressHook = fiber.memoizedState;
  // trigger component render
  fiber.stateNode();
  // first time render is mountï¼Œthe following update is update
  isMount = false;
}
```

Point to the current working `hook` by `workInProgressHook`.

```js
workInProgressHook = fiber.memoizedState;
```

When component `render`, we move the pointer of `workInProgressHook` everytime meet the next `useState`.

```js
workInProgressHook = workInProgressHook.next;
```

As the result, as long as the order and number of `useState` calls remain the same for each component `render`, the `hook` object corresponding to the current `useState` can always be found through `workInProgressHook`.

We have finished the first step so far, now we are going to implement the second step.

## Caculate State

When the component `render`, `useState` will be called and its logic looks like

```js
function useState(initialState) {
  // hook used in current useState will assigned the variable
  let hook;

  if (isMount) {
    // ...hook object generate when mount
  } else {
    // ...get the corresponding hook of the useState from workInProgressHook when update
  }

  let baseState = hook.memoizedState;
  if (hook.queue.pending) {
    // update state based on te update saved in the queue.pending
  }
  hook.memoizedState = baseState;

  return [baseState, dispatchAction.bind(null, hook.queue)];
}
```

Let's focus on how to get the `hook` object.

```js
if (isMount) {
  // useState generates hook when mount
  hook = {
    queue: {
      pending: null,
    },
    memoizedState: initialState,
    next: null,
  };

  // insert hook to the end of fiber.memoizedState chain
  if (!fiber.memoizedState) {
    fiber.memoizedState = hook;
  } else {
    workInProgressHook.next = hook;
  }
  // move the pointer of the workInProgressHook
  workInProgressHook = hook;
} else {
  // find the corresponding hook when update
  hook = workInProgressHook;
  // move the pointer of workInProgressHook
  workInProgressHook = workInProgressHook.next;
}
```

When find the corresponding hook of useState, if `hook.queue.pending` is not null, update the `state`.

```js
// initialState state before update
let baseState = hook.memoizedState;

if (hook.queue.pending) {
  // get the first update in the circular linked list
  let firstUpdate = hook.queue.pending.next;

  do {
    // execute update action
    const action = firstUpdate.action;
    baseState = action(baseState);
    firstUpdate = firstUpdate.next;

    // end loop after last update executed
  } while (firstUpdate !== hook.queue.pending.next);

  // clear queue.pending
  hook.queue.pending = null;
}

// use state after update action executed as memoizedState
hook.memoizedState = baseState;
```

Complete code:

```js
function useState(initialState) {
  let hook;

  if (isMount) {
    hook = {
      queue: {
        pending: null,
      },
      memoizedState: initialState,
      next: null,
    };
    if (!fiber.memoizedState) {
      fiber.memoizedState = hook;
    } else {
      workInProgressHook.next = hook;
    }
    workInProgressHook = hook;
  } else {
    hook = workInProgressHook;
    workInProgressHook = workInProgressHook.next;
  }

  let baseState = hook.memoizedState;
  if (hook.queue.pending) {
    let firstUpdate = hook.queue.pending.next;

    do {
      const action = firstUpdate.action;
      baseState = action(baseState);
      firstUpdate = firstUpdate.next;
    } while (firstUpdate !== hook.queue.pending.next);

    hook.queue.pending = null;
  }
  hook.memoizedState = baseState;

  return [baseState, dispatchAction.bind(null, hook.queue)];
}
```

## Abstract the Trigger Event

In the end, let's abstract the way `React` triggers events.

Simulate the behavior of a component `click` by calling the `click` method returned by the `App`.

```js
function App() {
  const [num, updateNum] = useState(0);

  console.log(`${isMount ? "mount" : "update"} num: `, num);

  return {
    click() {
      updateNum((num) => num + 1);
    },
  };
}
```

## Compare with React

We simulated `Hooks` operation with as less code as possible, but compared to `React Hooks`, it has many shortcomings. The following are the differences between it and `React Hooks`.

- `React Hooks` does not use `isMount` variable, but different `dispatcher` at different times. in other words, `useState` at `mount` is not the same function as `useState` at `update`.

- `React Hooks` has the optimization of skipping `Update` in the middle.

- `React Hooks` has `batchedUpdates`, when triggering `updateNum` three times in a `click`, lite `React` will trigger three updates, while `React` will only trigger once.

- `React Hooks` has a `priority` concept for `update`, so those `update` that are not high priority can be skipped.

More details will be explained in the following article of this chapter.
